# This script generates a block mesh file description to be used
# in OpenFoam
# The mesh can be inclined. The 2D scheme follows
#
#    . h
#    .
#        . w
#             .  . h
#          a (   .
# where
#    h is the mesh height (z direction)
#    w is the mesh width (inclination direction)
#    a is the inclination angle

import sys
import os
import argparse
import math
from pathlib import Path

file_header = "/*--------------------------------*- C++ -*----------------------------------*/\n" \
              "\n// File was generated by SwiftBlock, a Blender 3D addon.\n" \
              "FoamFile\n" \
              "{\n" \
              "    version     2.0;\n" \
              "    format      ascii;\n" \
              "    class       dictionary;\n" \
              "    object      blockMeshDict;\n" \
              "}\n" \
              "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n" \
              "deltaT          1;\n" \
              "writeInterval   1;\n\n" \
              "// ************************************************************************* //\n\n"


def desc_boundary(name, patch_type, faces):
    s = "\t" + name + "\n\t{\n"
    s += "\t\ttype " + patch_type + ";\n"
    s += "\t\tfaces\n\t\t(\n"
    s += "\t\t" + faces + "\n"
    s += "\t\t);\n"
    s += "\t}\n"
    return s


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', type=Path, help="output directory")
    parser.add_argument('-cx', type=float, help="cell size in x direction", default=1)
    parser.add_argument('-cy', type=float, help="cell size in y direction", default=1)
    parser.add_argument('-cz', type=float, help="cell size in z direction", default=1)
    parser.add_argument('-w', type=float, help="width - x direction")
    parser.add_argument('--height', type=float, help="height - z direction")
    parser.add_argument('-d', type=float, help="depth - y direction", default=1)
    parser.add_argument('-a', type=float, help="angle in degrees", default=0)
    parser.add_argument('-b', type=str, help="bottom patch name", default="terrain")
    parser.add_argument('-t', type=str, help="top patch name", default="top")
    parser.add_argument('-l', type=str, help="left patch name", default="inlet")
    parser.add_argument('-r', type=str, help="right patch name", default="outlet")
    parser.add_argument('-fb', type=str, help="walls patch name", default="frontAndBack")
    parser.add_argument('--b-type', type=str, help="bottom patch name", default="patch")
    parser.add_argument('--t-type', type=str, help="top patch type", default="patch")
    parser.add_argument('--l-type', type=str, help="left patch type", default="patch")
    parser.add_argument('--r-type', type=str, help="right patch type", default="patch")
    parser.add_argument('--fb-type', type=str, help="walls patch type", default="patch")
    parser.add_argument('--D2', action='store_true')
    args = parser.parse_args()

    if args.o is None or not os.path.isdir(args.o):
        print("bad output directory")
        exit()

    if (args.o / "blockMeshDict").exists():
        print("output block mesh file already exists")
        exit(1)

    # compute angle elevation
    e = args.w * math.sin(math.radians(args.a))

    # get block dimensions
    w = args.w * math.cos(math.radians(args.a))
    h = args.height
    d = args.d
    cx = args.cx * math.cos(math.radians(args.a))
    cy = args.cy
    cz = args.cz

    half_d = d / 2
    min_d, max_d = -half_d, half_d
    if args.D2:
        min_d, max_d = 0, 1
        res_d = 1
    else:
        res_d = d // cy

    if cz * 1.75 < h:
        cz *= 1.75

    # block resolution
    res = [args.w // cx, int(res_d), h // cz]

    print("elevation = %.2fm" % e)
    print("x width = %.2fm" % w)
    print("y width = %.2fm" % d)
    print("resolution = (%d %d %d)" % (res[0], res[1], res[2]))

    # write header
    file_content = file_header

    # write geometry
    file_content += "geometry\n{\n}\n"

    # write vertices
    file_content += "vertices\n(\n"
    file_content += "\t(%.2f %.2f %.2f)\n" % (0, min_d, e + 0)
    file_content += "\t(%.2f %.2f %.2f)\n" % (0, min_d, e + h)
    file_content += "\t(%.2f %.2f %.2f)\n" % (0, max_d, e + 0)
    file_content += "\t(%.2f %.2f %.2f)\n" % (0, max_d, e + h)
    file_content += "\t(%.2f %.2f %.2f)\n" % (w, min_d, 0)
    file_content += "\t(%.2f %.2f %.2f)\n" % (w, min_d, h)
    file_content += "\t(%.2f %.2f %.2f)\n" % (w, max_d, 0)
    file_content += "\t(%.2f %.2f %.2f)\n" % (w, max_d, h)
    file_content += ");\n"

    # write edges
    file_content += "edges\n(\n);\n"

    # write faces
    file_content += "faces\n(\n);\n"

    # write blocks
    file_content += "blocks\n(\n"
    file_content += "\thex (0 2 3 1 4 6 7 5) (%d %d %d)\n" % (res[1], res[2], res[0])
    file_content += "\tsimpleGrading (1 10 1)"
    file_content += "\n);\n"

    # write boundary
    file_content += "boundary\n(\n"
    # fb
    if args.D2:
        file_content += desc_boundary(args.fb, "empty", "(2 3 7 6)\n\t\t(4 5 1 0)")
    else:
        file_content += desc_boundary(args.fb, args.fb_type, "(2 3 7 6)\n\t\t(4 5 1 0)")
    file_content += desc_boundary(args.b, args.b_type, "(2 6 4 0)")
    file_content += desc_boundary(args.t, args.t_type, "(7 3 1 5)")
    file_content += desc_boundary(args.l, args.l_type, "(0 1 3 2)")
    file_content += desc_boundary(args.r, args.r_type, "(6 7 5 4)")
    file_content += "\n);\n"

    # write patches
    # file_content += "patches\n(\n"
    # if args.D2:
    #     file_content += "\tempty " + args.fb + "\n\t(\n\t\t(2 3 7 6)\n\t\t(4 5 1 0)\n\t)\n"
    # else:
    #     file_content += "\tpatch " + args.fb + "\n\t(\n\t\t(2 3 7 6)\n\t\t(4 5 1 0)\n\t)\n"
    # file_content += "\tpatch " + args.b + "\n\t(\n\t\t(2 6 4 0)\n\t)\n"
    # file_content += "\tpatch " + args.t + "\n\t(\n\t\t(7 3 1 5)\n\t)\n"
    # file_content += "\tpatch " + args.l + "\n\t(\n\t\t(0 1 3 2)\n\t)\n"
    # file_content += "\tpatch " + args.r + "\n\t(\n\t\t(6 7 5 4)\n\t)\n"
    # file_content += "\n);\n"

    with open(args.o / "blockMeshDict", "w") as f:
        f.write(file_content)
